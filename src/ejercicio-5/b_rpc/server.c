/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "miniop.h"

float * add_1_svc(aritmetic_req *argp, struct svc_req *rqstp){
	static float  result;

	/*
	 * insert server code here
	 */
	 
	int i;
	result = 0;
	
	for(i=0; i<argp->cant_op; i++){
		result+=argp->arr[i];
	}
	
	return &result;
}

float * sub_1_svc(aritmetic_req *argp, struct svc_req *rqstp){
	static float  result;

	/*
	 * insert server code here
	 */
	 
	int i;
	result = argp->arr[0];
	
	for(i=1; i<argp->cant_op; i++){
		result-=argp->arr[i];
	}

	

	return &result;
}

float * mul_1_svc(aritmetic_req *argp, struct svc_req *rqstp){
	static float  result;

	/*
	 * insert server code here
	 */
	 
	int i;
	result = argp->arr[0];
	
	for(i=1; i<argp->cant_op; i++){
		result*=argp->arr[i];
	}

	return &result;
	
}

float * div_1_svc(aritmetic_req *argp, struct svc_req *rqstp){
	static float  result;

	/*
	 * insert server code here
	 */
	 
	int i;
	result = argp->arr[0];
	
	for(i=1; i<argp->cant_op; i++){
		result/=argp->arr[i];
	}

	return &result;
}

number_conv * dectobin_1_svc(long *argp, struct svc_req *rqstp){
	static number_conv  result;

	/*
	 * insert server code here
	 */
	 
	long decbin = (*argp);
	int mod=0,i=0;
	char aux;
	
	
	for(i=0;decbin>0;i++){
		mod = decbin%2;
		result.num[i] = mod + '0';
		decbin/=2;
	}
	
	result.num[i] = '\0';
	
	int medio = i/2; 
	int fin = i-1;
	
	for(i=0;i<medio;i++){
		aux = result.num[i];
		result.num[i] = result.num[fin-i];
		result.num[fin-i] = aux; 
	}
	 
	return &result;
}

number_conv * bintohexa_1_svc(long *argp, struct svc_req *rqstp){
	
	static number_conv  result;

	/*
	 * insert server code here
	 */
	 
	 int hexConstant[] = {0, 1, 10, 11, 100, 101, 110, 111, 1000, 
                         1001, 1010, 1011, 1100, 1101, 1110, 1111};

    int index, i, digit;
	
	long decbin = (*argp), temp;

	char aux;
	
	temp = decbin;
    index = 0;
	
	while(temp!=0)
    {
        /* Obtengo los últimos 4 digitos binarios */
        digit = temp % 10000;

        /* Encuentro el dígito Hexa relacionado a los últimos 4 dígitos binarios*/
        for(i=0; i<16; i++)
        {
            if(hexConstant[i] == digit)
            {
                if(i<10)
                {
                    /* Digitos entre 0 y 9  */
                    result.num[index] = (char)(i + 48);
                }
                else
                {
                    /* Digitos de la A a la F */
                    result.num[index] = (char)((i-10) + 65);
                }

                index++;
                break;
            }
        }

        /* Remove the last 4 digits as it is processed */
        temp /= 10000;
    }
	
	result.num[index] = '\0';
	
	int medio = index/2; 
	int fin = index-1;
	
	for(i=0;i<medio;i++){
		aux = result.num[i];
		result.num[i] = result.num[fin-i];
		result.num[fin-i] = aux; 
	}

	return &result;
}
